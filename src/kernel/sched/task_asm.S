/* MIT License
 *
 * Copyright (c) 2017 GrieferAtWork
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <kos/asm.h>
#include <kos/symbol.h>
#include <kos/kernel/features.h>
#include <kos/kernel/gdt.h>
#include <kos/kernel/interrupts.h>
#include <kos/kernel/task.h>
#include <kos/kernel/proc.h>
#include <kos/arch.h>
#ifdef __x86__
#include <kos/arch/x86/eflags.h>
#endif

/* Low-level IRQ #32 handler (no c-prototype as this one's directly called by the CPU) */
GLOBAL_FUNCTION(ktask_irq):
	PUSH_REGISTERS
	SET_KERNEL_SEGMENTS

	movI %esp, %ecx
	movI %esp, %edx

	DISABLE_PAGING
	/* ESP is still part of the user's address space. - Let's change that! */
	/* Translate address in %ECX. */
	TRANSLATE_VADDR %ecx, %ebx, %eax
	movI %ebx, %esp

#ifdef __DEBUG__
	pushI (8*PS)(%esp) /* Fix return address (for tracebacks). */
#endif
	STACKBEGIN
	movI  %cr3, %eax
	pushI %eax
	pushI %edx // User-address for registers

	leaI __kpagedir_kernel, %eax
	movI %eax, %cr3  /* Set the kernel's page directory. */
	ENABLE_PAGING

	pushI %esp
	call _S(ktask_schedule)
	popI %ebx

	movI (PS*0)(%ebx), %esp
	movI (PS*1)(%ebx), %eax
	movI %eax, %cr3

	POP_REGISTERS_NOEAX

	/* Signal interrupt handling completion */
	mov8 $0xa0, %al
	out8 %al, $0x20
	mov8 $0x20, %al
	out8 %al, $0x20

	popI %eax
	iret
SYMBOLEND(ktask_irq)

/* void ktask_switchimpl(struct ktask *newtask, __ref struct ktask *oldtask) */
GLOBAL_FUNCTION(ktask_switchimpl):
	/* Must transform the stack to look like it was generated by an interrupt
	 * BEFORE:  #+8  oldtask
	 *          #+4  newtask
	 *          # 0  EIP (return addr)
	 * AFTER:   #+16 oldtask
	 *          #+12 newtask
	 *          #+8  EFLAGS
	 *          #+4  CS
	 *          # 0  EIP (return addr)
	 *          #-4  EAX
	 *          #-8  EBX
	 *          #-12 ...
	 * NOTE: The additional fields of ring-3 tasks don't matter, since
	 *       'ktask_switchimpl' can't be called from ring-3 without
	 *       going through a system-call (at which point it's ring-0)
	 */
	movI %eax, (-3*PS)(%esp) /* Save the corrent EAX where it belongs */
	movI 0(%esp), %eax
	movI %eax, (-2*PS)(%esp) /* Save the corrent EIP where it belongs */
	mov %cs, %eax
	movI %eax, (-1*PS)(%esp) /* Save the corrent CS where it belongs */
	addI $PS, %esp
	movI %esp, %eax          /* Load address of '#+12 (newtask)' */
	pushfI                   /* EFLAGS */
	subI $(PS*3), %esp       /* Adjust stack to now hover over EAX */

	PUSH_REGISTERS2_NOEAX
	movI (PS*0)(%eax), %ebx /* newtask (EBX) */
	movI (PS*1)(%eax), %ecx /* oldtask (ECX) */

	movI %cr3, %eax
	movI %eax, (KTASK_OFFSETOF_PD)(%ecx)
	movI %esp, (KTASK_OFFSETOF_ESP)(%ecx)

	/* Figure out the kernel-ESP of the new task */
	pushI %ecx
	pushI %ebx
	call _S(ktask_getkernelesp_n)
	popI %ebx
	popI %ecx

	movI %eax, %esp
	/* We're now in the kernel-space ESP of the new task */

	/* Switch the LDT table if the new task's differs from the old. */
	movI KTASK_OFFSETOF_PROC(%ebx), %eax
	movI KTASK_OFFSETOF_PROC(%ecx), %edx
	cmpI %eax, %edx
	jz .skip_ldt

	/* Different processes -> Load LDT from 'struct kproc *%eax' */
	lldt (KPROC_OFFSETOF_SHM  \
	    + KSHM_OFFSETOF_LDT   \
	    + KLDT_OFFSETOF_GDTID \
	)(%eax)

.skip_ldt:

	pushI %ebx
	pushI %ecx
	call _S(ktask_decref_f)
	addI $PS, %esp
//	popI %ecx
	popI %ebx

	/* Update the ESP0 in the cpu's TSS */
	pushI %ebx
	movI (KTASK_OFFSETOF_ESP0)(%ebx), %edx
	pushI %edx
	call _S(kcpu_setesp0)
	POPARGS(1)
	popI %ebx

	/* Switch to the user-space ESP and set the task's Page directory */
	movI (KTASK_OFFSETOF_PD)(%ebx), %eax
	movI (KTASK_OFFSETOF_ESP)(%ebx), %ecx

	movI %eax, %cr3
	movI %ecx, %esp

#if KCONFIG_HAVE_I386_SAVE_SEGMENT_REGISTERS
	pop16 %ds
	pop16 %es
	pop16 %fs
	pop16 %gs
#else
	pop16 %bx
	mov16 %bx, %ds
	mov16 %bx, %es
	mov16 %bx, %fs
	mov16 %bx, %gs
	addI $2, %esp
#endif
	pop32 %edi
	pop32 %esi
	pop32 %ebp
	pop32 %ebx
	pop32 %edx
	pop32 %ecx
	pop32 %eax
	/* Use iret because our stack is correctly layed out */
	iret
SYMBOLEND(ktask_switchimpl)




GLOBAL_FUNCTION(ktask_exitnormal):
	DEBUGNOP /* So we can point the EIP in a way that includes 'ktask_exitnormal' in tracebacks. */
	pushI %eax
	call _S(ktask_exit)
	DEBUGNOP /* To make sure that the return address stays inside of 'ktask_exitnormal' */
SYMBOLEND(ktask_exitnormal)
