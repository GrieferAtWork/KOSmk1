/* MIT License
 *
 * Copyright (c) 2017 GrieferAtWork
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <kos/asm.h>
#include <kos/symbol.h>
#include <kos/kernel/features.h>
#include <kos/kernel/gdt.h>
#include <kos/kernel/interrupts.h>
#include <kos/kernel/task.h>
#include <kos/arch.h>
#ifdef __x86__
#include <kos/arch/x86/eflags.h>
#endif

/* Low-level IRQ #32 handler (no c-prototype as this one's directly called by the CPU) */
GLOBAL_FUNCTION(ktask_irq):
	PUSH_REGISTERS
	SET_KERNEL_SEGMENTS

	movI %esp, %ecx
	movI %esp, %edx

	DISABLE_PAGING
	/* ESP is still part of the user's address space. - Let's change that! */
	/* Translate address in %ECX. */
	TRANSLATE_VADDR %ecx, %ebx, %eax
	movI %ebx, %esp

#ifdef __DEBUG__
	pushI (8*PS)(%esp) /* Fix return address (for tracebacks). */
#endif
	STACKBEGIN
	movI  %cr3, %eax
	pushI %eax
	pushI %edx // User-address for registers

	leaI __kpagedir_kernel, %eax
	movI %eax, %cr3  /* Set the kernel's page directory. */
	ENABLE_PAGING

	pushI %esp
	call _S(ktask_schedule)
	popI %ebx

	movI (PS*0)(%ebx), %esp
	movI (PS*1)(%ebx), %eax
	movI %eax, %cr3

	POP_REGISTERS_NOEAX

	/* Signal interrupt handling completion */
	mov $0xA0, %al
	outb %al, $0x20
	mov $0x20, %al
	outb %al, $0x20

	popI %eax
	iret
SYMBOLEND(ktask_irq)

/* void ktask_switchimpl(struct ktask *newtask, __ref struct ktask *oldtask) */
GLOBAL_FUNCTION(ktask_switchimpl):
	/* Must transform the stack to look like it was generated by an interrupt
	 * BEFORE:  #+8  oldtask
	 *          #+4  newtask
	 *          # 0  EIP (return addr)
	 * AFTER:   #+16 oldtask
	 *          #+12 newtask
	 *          #+8  EFLAGS
	 *          #+4  CS
	 *          # 0  EIP (return addr)
	 *          #-4  EAX
	 *          #-8  EBX
	 *          #-12 ...
	 * NOTE: The additional fields of ring-3 tasks don't matter, since
	 *       'ktask_switchimpl' can't be called from ring-3 without
	 *       going through a system-call (at which point it's ring-0)
	 */
	movI %eax, (-3*PS)(%esp) /* Save the corrent EAX where it belongs */
	movI 0(%esp), %eax
	movI %eax, (-2*PS)(%esp) /* Save the corrent EIP where it belongs */
	mov %cs, %eax
	movI %eax, (-1*PS)(%esp) /* Save the corrent CS where it belongs */
	addI $PS, %esp
	movI %esp, %eax          /* Load address of '#+12 (newtask)' */
	pushfI                   /* EFLAGS */
	subI $(PS*3), %esp       /* Adjust stack to now hover over EAX */

	PUSH_REGISTERS2_NOEAX
	movI (PS*0)(%eax), %ebx /* newtask (EBX) */
	movI (PS*1)(%eax), %ecx /* oldtask (ECX) */

	movI %cr3, %eax
	movI %eax, (KTASK_OFFSETOF_PD)(%ecx)
	movI %esp, (KTASK_OFFSETOF_ESP)(%ecx)

	/* Figure out the kernel-ESP of the new task */
	pushI %ecx
	pushI %ebx
	call _S(ktask_getkernelesp_n)
	popI %ebx
	popI %ecx

	movI %eax, %esp
	/* We're now in the kernel-space ESP of the new task */

	pushI %ecx
	call _S(ktask_decref_f)
	POPARGS(1)

	/* Update the ESP0 in the cpu's TSS */
	pushI %ebx
	movI (KTASK_OFFSETOF_ESP0)(%ebx), %edx
	pushI %edx
	call _S(kcpu_setesp0)
	POPARGS(1)
	popI %ebx

	/* Switch to the user-space ESP and set the task's Page directory */
	movI (KTASK_OFFSETOF_PD)(%ebx), %eax
	movI (KTASK_OFFSETOF_ESP)(%ebx), %ecx
	movI %eax, %cr3
	movI %ecx, %esp

	POP_REGISTERS
	/* Use iret because our stack is correctly layed out */
	iret
SYMBOLEND(ktask_switchimpl)




GLOBAL_FUNCTION(ktask_exitnormal):
	DEBUGNOP /* So we can point the EIP in a way that includes 'ktask_exitnormal' in tracebacks. */
	pushI %eax
	call _S(ktask_exit)
	DEBUGNOP /* To make sure that the return address stays inside of 'ktask_exitnormal' */
SYMBOLEND(ktask_exitnormal)


GLOBAL_FUNCTION(ktask_ring3_bootstrap):
#if 1
#undef POP_REGISTERS_FROM_ESP0
#include "task_asm-ring3-bootstrap.S.inl"
#else
	/* NOTE: The task setup will have set up the stack:
	 *     +0:  User-ESP0
	 *     +4:  Physical address of the user's page directory (CR3)
	 *     +8:  User-ESP
	 *     +12: User-EIP
	 * NOTE: With ESP0 already at the top of the stack,
	 *       we don't need to re-arrange anything.
	 */
	call _S(kcpu_setesp0)
	movI $(KSEGMENT_USER_DATA|3), %eax /* |3: RPL: Request ring 3 */
	movI %eax, %ds
	movI %eax, %es 
	movI %eax, %fs 
	movI %eax, %gs 

	/* Load the given arguments into registers */
	movI (PS*0)(%esp), %eax /* ESP0 */
	movI (PS*1)(%esp), %ebx /* CR3 */
	movI (PS*2)(%esp), %ecx /* ESP */
	movI (PS*3)(%esp), %edx /* EIP */

	/* Switch to the virtual kernel stack and enable paging */
	movI %eax, %esp
	movI %ebx, %cr3

#ifdef __DEBUG__
	/* Push some stuff to make this stack appear ~normal~ */
	pushI $0 /* Return address */
	pushI $0 /* Old EBP */
	movI %esp, %ebp
#endif

	/* NOTE: The |3 in these describe the current ring (which will be 3, the CPL in SS and CS) */
	pushI $(KSEGMENT_USER_DATA|3)  // SS     (0x23)
	pushI %ecx                     // ESP    (bootstrap)
	pushI $(KARCH_X86_EFLAGS_IF)   // EFLAGS (IF)
	pushI $(KSEGMENT_USER_CODE|3)  // CS     (0x1B)
	pushI %edx                     // EIP    (bootstrap)

#if KCONFIG_SECUREUSERBOOTSTRAP
	movI $0,   %eax
	movI %eax, %ebx
	movI %eax, %ecx
	movI %eax, %edx
	movI %esp, %ebp
#endif
	iret
#endif
SYMBOLEND(ktask_ring3_bootstrap)

GLOBAL_FUNCTION(ktask_ring3_bootstrap_regs):
#define POP_REGISTERS_FROM_ESP0
#include "task_asm-ring3-bootstrap.S.inl"
SYMBOLEND(ktask_ring3_bootstrap_regs)
